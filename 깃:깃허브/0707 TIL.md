# 220707 TIL



## 복습

### git: 분산버전관리시스템 by 커밋 -->repository

* 보고서를 쓰고 있음->서론/본론/결론/퇴고 

* 본론 썼던 버전 싫어! 버전 되돌리면 된다. 버전 되돌리는 법: 

* 커밋 메세지를 다르게 하고 싶다면 파일 별로 각각 커밋을 하면된다! git add '파일명.md' (확장자까지 쓰기) 후 git commit -m

* 폴더명을 입력하면 폴더 안의 내용이 모두 커밋되니 폴더 안 파일들을 각각 커밋하시려면 'cd 폴더명'으로 들어가서 각각 커밋하자 

* git add. 은 .gitignore을 고려하고 add하는 것이고 git add*은 .gitignore을 고려하지 않고 모두 add하는 것

* 경로 확인은 필수!!! 깃 인잇해야 master 브랜치에 위치한 것

* .txt 만들고 vs코드에서 내용 적을 수 있다

* 커밋 메세지는 행위에 대한 기록이다

* 나무위키 버전으로 돌아가면 내가 보는 파일의 갯수는? 4개!

  * git checkout 

* 과거로 돌아가면 삭제된 파일 보인다 

* *커밋한 모든 내용은 다시 되돌릴 수 있음*

* *커밋하지 않은 모든 내용은 손 쓸 방법이 없어요!*

* 깃헙에 있는 폴더 지우는 방법? *로컬에서 지우고 커밋한 다음 다시 푸쉬하면 돼 원격저장소는 건들지마*

* 깃은 버전만 관리하는 것이다! 파일을 만들거나 보고서를 쓰는 건 너가 하는 대로만 해라. 깃은 슈퍼맨은 아니다

  

## 타이포라 이슈

* 마크다운 이미지 경로 등 이슈
  * images로 파일 위치 바꾸면 상대경로에서 안 보이게 된다
  * 폴더나 파일을 이동시키면 타이포라에서도 안 보인다. 경로가 바뀌었으니까. 
  * 한땀한땀 경로바꾸면 됨
  * 파일명을 한글->영어로 바꾸면, 해당 위치를 찾을 수 없습니다. -->한땀한땀 쓰면 됨
  * 파일 이름을 신중하게 하거나, 일단 밀고 가자
  * 러버덕 디버깅\



## GITHUB CLONE

```GIT 
 $ GIT CLONE 주소
```

주의사항: 클론하면 원격저장소 이름의 폴더(TIL.GIT)가 생성된다

그 폴더를 열고 !!! 작업 시작해야 한다 (이름 동일하면 충돌 일어남)

주소 입력하고 cd로 해당 파일 들어가야 log 볼 수 있다

git pull해서 선생님이 새로 원격에 올라온 거 받아올 수 있음

그러나 아직은 커밋해서 푸쉬할 수는 없다. 



#### 집파일 압축 VS. 클론 주소

* **둘의 차이점은?** 
  * 마스터의 유무! 클론으로 열먼 마스터로 열리고, 압축 파일로 연다면 마스터가 아니다.
  * 압축으로 열면 최신 버전의 파일/폴더만 여는 것 ->이걸로 작업하면 새로운 역사를 열게 된다
  * 클론으로 열면 GIT 저장소를 가지고 온 것 -->LOG 보면 다 보인다. 이게 바로 분산버전



### pull

  * 클론을 받고 init을 써야 한다? 안해야 한다? **안해야 한다! **
    * 풀도 받아오고 클론도 받아오는 것인데, 둘의 차이점은?
    * PULL: 변경된 **커밋**을 받아옴
    * CLONE: 저장소를 받아옴 

팀 프로젝트를 시작할 때 조장이 해야하는 일 단톡방에 말함 . 주장이 구글 드라이브를 만들고 초대. 조원은 구글드라이브에 접속. 다운받음



조장은 로컬 저장소를 만들어서(GIT INIT) 깃헙에 원격저장소로 푸쉬 ->조원은 GIT CLONE으로 받아온다. 클론 받아온 이후에 푸쉬와 풀을 이용. 푸쉬와 풀은 커밋만 업데이트된다. 



### Git 들어가기 전에

#### git add . 에서 .의 뜻

->현재 디렉토리 중에서 변경된 파일들만! 변경되지 않는 파일은 add되지 않는다.

#### git flow 

> Git을 활용하여 협업하는 흐름으로 branch를 활용하는 전략을 의미



휴가로고 가지

네이버페이 이벤트 가지

작업 시작하면 각자 하다가 작업 끝나면 branch 합치면 된다

master는 사용자가 보는 화면에 대한 코드



## Branch basic commands

> 브랜치의 목적: 독립된 버전을 만들기 위해서



### Branch merge

> branch에서 작업을 한 이후 이력(커밋/버전)을 합치기 위해서 merge 명령어 사용

#### branch merge - fast-forward



처음에 commit 해야 루트가 생김 

`$ git branch`



깃 브랜치 -브랜치 조회

깃 브랜치 이크잼플 - 이그잼플이라는 브랜치가 생긴다

깃 

깃 체크아웃 이그잼플: 브랜치 이동  

switched to branch 'example' 

master-->example 브랜치로 변경된다



2번째 스샷

마스터 가서 로그 찍으면 이그잼플 txt가 없어짐 

왜? 파일이 없어진건 결과론적인 거고. 

이그잼플에서 로그가 2개였는데, 마스터에서 로그는 1개만 뜬다 

다시 이그잼플로 들어가면 로그 2개 나온다

* head->example에서 head의 의미? 나는 example로 이동해서 위치
* ​       ->master: 나는 첫번째 기준점이 되는 커밋만 보겠다  
  * head: 머리 :이동해서 위치 정보를 가지고 있는게 head 
* git checkout master ->git merge example 병합 *마스터 가서  example병합*
* 그러면 마스터에서 이그잼플 텍스트가 생기고, 로그에서도 읽힌다
* 머지 한다고 이그잼플 브랜치가 사라지는 것은 아님. 
* 만약에 마스터에서 이그잼플 브랜치를 지운다면, 커밋도 지워진다? 파일 없어지는 거 아니에요? x
  * 이미 마스터에 합쳐놨기 때문에 상관 없다
  * 마스터에 합치면 보통 브랜치는 삭제한다. 가지치기



브랜치 git github 작업은 결국 작업/협업을 하기 위함

브랜치라는 것은 특정한 버전들의 흐름 (즉, 작업 내역들)



상황 3. 서로 같은 파일 협업으로 작업하는 경우(진정한 협업)

-->각각 파일 작성 완료 후 조장은 수작업으로 고친 후 취합을 해야 한다



상황1. 혼자 작업, 조원 프리라이딩 (fast-forward)

-홈 화면을 만든다. (home.txt)

git branch feature/home

git checkout feature/home

touch home.txt

git add .

commit -m 'complete home'

git checkout master



하나로 머지하면 마스터이자 피쳐가 된다!



2. 보고서 파일+ 발표자료 파일 (각자 커밋이 발생했는데, 다른 파일만 수정된 경우)

> 서로 다른 커밋을 병합하는 과정에서 **다른 파일이 수정** 되어 있는 상황

`(master) $ git checkout -b feature/about`

feature/about 브랜치를 만들면서 이동할게



3번째 파일 다른데 머지함

> (head->master)Merge branch 'feature/about'

-->새로운 초록색 커밋(두개가 합쳐짐)이 생기면서 머지가 됨. 

머지는 마스터에서 나온 가지를 다시 마스터로 붙이는 것. 

병합된 브랜치는 삭제한다. 



상황 3. 진정한 협업 merge commit 충돌

> 서로 다른 커밋을 병합하는 과정에서 **같은 파일의 동일한 부분이 수정**되어 있는 상황. 

두 커밋 다 같은 readme 파일이 수정된 것 ->master에서 병합(git merge feature/test)하면 merge conflict (커밋을 안 만들어준다) 발생-->(master/MERGING)

어떤 명령어로 충돌된 파일들을 다 볼 수 있을까?

`$ git status` --->both modified 확인 가능

로그는 아니다! 아직 커밋이 안 되었으니까



메모장으로 열면 

HEAD(내가 지금 있는 곳)

==

테스트에서 쓰인 것



-->이제 내가 해야 하는 것은? 편집은 내가 한다.



브랜치 병합 과정에서 충돌난 학생들이 항상 저 충돌났어요~~ 하고 달려와요.

여러분들은 어떻게 이야기해줄건가요?



=조모임하다가 조원이 피피티 다르다고 그냥 들고 왔어요. 교수님에게 교수님은 뭐라고 하실까요?

A. 여러분이 개발하는 방향에 맞게 고치세요^^ 뭐하고 싶으세요 ^^ 



고친 다음에 해야하는 것

GIT ADD . ->GIT COMMIT ->MASTER/MERGING 없어지고 MASTER만 됨

GIT LOG 하면 MERGE BRANCH된 거 볼 수 있다.



결국 2 3은 결과가 같음/ 3은 내가 충돌난 부분을 **직접 고쳐서 애드- 커밋을 해야 한다는 것 뿐!**







## GITHUB 협업



### GITBUB FLOW 기본 원칙

#### 1) FEATURE BRANCH WORKFLOW -저장소의 소유권이 있는 경우

* 각자 만들고 각자 푸쉬/ PULL 리쿼스트를 통해서 병합은 로컬에서 하지 않는다. 병합 완료된 브랜를 깃헙에서 삭제. 

#### 2) FORKING WORKFLOW -저장소의 소유권이 없는 경우



#### PULL REQUEST



#### 1)FEATURE BRANCH WORKFLOW -저장소의 소유권이 있는 경우



깃 푸쉬 오리진 핫픽스

크리에이트 어 풀 리쿼스트 핫픽스

깃헙 가서 NEW PULL REQUEST 눌러 ->핫픽스 브랜치를 마스터 브랜치에 합치는 걸 요청하는 것

글 설명 쓰고 CREATE PULL REQUEST 하면 풀 리퀘스트 끝

밑에 머지 풀 리퀘 누르면 머지 된다



정리

로컬 저장소                               원격 저장소

123                                               123

a 브랜치   -->깃 푸쉬 오리진 a       -->a 생기고 풀 리퀘스트! 마스터 합쳐주세요



브랜치 작업은 로컬에서 각각 ->모든 머지 작업을 원격저장소인 깃헙에서 하는 것이다.

병합을 제일 잘하는 사람이 방장이 해야 한다... 





#### 2) FORKING WORKFLOW -저장소의 소유권이 없는 경우

주인장이 아닌데 수정 하고 싶어! ->포크로 찍어서 가져온다. 우측상단 fork를 누른다. ->create a new fork

->owner 내 이름으로 포크가 뜬다.  -->내 유저네임/pull shark forked from/원래 주인장

-->배쉬에서 깃 클론 주소



위 메모장 작업한 다음에 git add. ->commit -m '상어가족' ->git push origin main 

여기서 origin은? kdt라이브의 것

사이트 보면 is 1 commit ahead of 원주인

컨트리뷰트에 오픈 풀 리퀘스트도 있다->이거 누르면 베이직 리포지토리(원주인장) <-헤드 레포지토리(손님) 

확인 하고 create pull request누르면 된다 ->그러나 손님이라서 merge불가. merge는 주인장의 판단에 따라 가능



이미지 파일을 커밋하고 fexe를 따로 커밋하고 싶었는데 같이 add함

->이 경우 취소하는 방법은? get restore --staged  파일.확장자명 to unstage



고양이가 파일을 날린 경우, 날린 파일을 되돌리는 방법은?

->log는 아님 커밋 관련 없음 push pull 불가 우원격 한 번도 안했음 git restore









